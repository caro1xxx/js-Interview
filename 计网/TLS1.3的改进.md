#### 强化安全

TLS1.3中仅保留了**5个加密套件**

- TLS_AES_128_GCM_SHA256
- TLS_AES_256_GCM_SHA384
- TLS_CHACHA20_POLY1305_SHA256
- TLS_AES_128_GCM_SHA256
- TLS_AES_128_GCM_8_SHA256

*RSA相关加密套件被废弃*

废弃的大致原因

1. 2015年发现了`FREAK`攻击,有人发现了RSA的漏洞
2. 一旦秘钥泄露,中间人可以通过秘钥计算出之前所有拦截到的报文的`secret`(即破解之前的密文)

##### 重点

基于第二条进行解释:

在RSA握手中,客户端拿到服务器证书后,提取出服务器的公钥,然后生成`pre_random`并用`公钥`加密传给服务器,服务器通过`秘钥`解密,从而拿到真是的`pre_random`

当中间人拿到服务器私钥后,并且截取了之前所有的报文

那么就能拿到`pre_random`,`server_random`和`client_random`并根据对应的随机数函数生成`secret`

这个`secret`最终的TLS会话秘钥,每个历史报文都可以这样破解

> 但是`ECDHE`在**每次握手**时都会`生成临时的密钥对`,这样一来即使私钥被破解,也不会对历史消息造成影响,(*RSA不会每次握手都会生成临时的秘钥对*)
>
> 这种一次破解并不影响历史信息的性质称为*向前安全性*
>
> RSA不具备*向前安全性*

#### 会话复用

##### 方式一:Session ID

服务器和客户端首次连接时自动保存会话ID,当下次连接时,客户端发送ID到服务器,服务器查找该ID,如果存在就复用之前的状态,不重新生成会话秘钥

*缺点是一旦会话数量庞大的时候,服务器存储压力巨大*

##### 方式二:Session Ticket

> **将压力转嫁给客户端**

做法就是双方连接成功后,**服务器加密会话信息,**然后通过`Session Ticket`发送给客户端保存,**下次重连时**就把这个**Ticket进行解密**,**验证是否过期**,如果没有过期就沿用这个会话状态

*缺点是带来了安全问题,因为每次解密都是使用相同秘钥,一旦黑客拿到秘钥,之前的历史就被破解,所有应定期更换秘钥*

#### PSK

> TLS1.3通过让客户端*抢跑*实现了`1-RTT`即只需要一个握手
>
> 那么可不可以`0-RTT`呢?可以

在发送`Session Ticket`的同时带上应用数据，不用等到服务端确认，这种方式被称为`Pre-Shared Key`，即 PSK

但是如果被中间人截获RSK数据,不断向服务器重复发,增加了**服务器被攻击的风险**