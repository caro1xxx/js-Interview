#### JS

##### 修改原型上的值

```ts
__proto__
```

##### let ,const, var

仅var存在变量提升

let,const仅有暂时性死区

变量提升:
指的是在声明在使用之后,还是可以正常获取到变量

暂时性死区:

指的是let/const在声明之前使用,*因为变量还没有被当前作用域创建出来,此时还没有完成语法绑定*

而var在声明之前使用是正常的,只不过是undefined

##### 深拷贝

定义:如果仅是把当前对象赋值给另一个变量,这是赋值的引用,该变变量还是会导致原对象发生改变,深拷贝就是在当前内存中再生成一份原变量,而不是引用

内置方法

```js
JSON.stringfiy
```

手写

```ts
const deepClone = (obj) => {
  // 新建对象 | 数组
  let objClone = Array.isArray(obj) ? [] : {};
  // 判断传入的参数对象不为空
  if (obj && typeof obj === "object") {
    // 遍历所有key
    for (let key in obj) {
      // 如果对象的key也是对象
      if (obj[key] && typeof obj[key] === "object") {
        // 那么递归
        objClone[key] = deepClone(obj[key]);
      } else {
        // 反之放入新对象中
        objClone[key] = obj[key];
      }
    }
  }
  return objClone;
};
```

##### 操作dom

```js
// 获取全部div
let dom = document.querySelector("div")
// 获取id节点
let idNode = document.querySelector('#foo')
// 获取类节点
let classNode = document.querySelector(".class")
// 获取全部querySelectorAll , 内部是数组,可以使用下标进行获取单个
// let span = document.querySelector("span")
// 移除子节点
// dom.removeChild(span)
// 创建节点
// document.createElement('div', 3)
// 追加节点
// dom.appendChild(document.createElement('div', 3))
// 获取父节点
// dom.parentNode
// 获取子节点
// dom.childNodes
// 创建注释节点
// dom.appendChild(document.createComment("nihao"))
// 创建文本节点
// dom.appendChild(document.createTextNode('hello'))
```

##### 箭头函数

* 没有自己的this

* 没有arguments

* 语法简洁

* 不能用作构造函数,不能new

* 没有原型对象

  ```js
  function foo(){}
  foo.protoype // {constructor:f}
  const bar =() => {}
  bar.prototype // undefined
  ```

##### for循环的优点

程序简洁,结构清晰,循环初始化,循环变量化,循环体和循环条件位置退出

相比map,forEach**更好中途退出**

##### map,forEach区别

map 

有返回值

forEach

返回值undefined

*相同点:都接收一个执行函数,和一个this指向*

##### 如何解决精度问题

1. 使用字符串
2. 进行运算之前先将小数乘以N倍变成整数后再计算后除以之前的N倍
3. 使用第三库

##### null和undefined的区别

###### null

标识空值,即无没有东西了,不存在这个东西,GC可以删除了

###### undefined

声明后为赋值,变量提升,函数无返回都会出现undefined

##### 未声明和未定义的区别

声明:*不开辟内存*,只告诉编译器,要声明的部分存在,要*预留部分空间*

定义:要开辟内存

```js
let x //声明
let f = 1; //定义
```

#### CSS

##### position

relative:相对于其**正常位置**进行定位

Aboslute:相当于**static定位以外的第一个父元素进行定位**

fixed:相对于**浏览器窗口**进行定位

static:*元素默认值,没有定位*

inherit:继承**父元素position**

sticky:可以被认为是**相对定位和固定定位的混合**。元素在跨越特定阈值前为相对定位，之后为固定定位。设置该属性的元素并不脱离文档流，仍然保留元素原本在文档流中的位置

##### display

None:从文档流中**排除该元素**

block:块级元素,该元素*前后会有换行符*

inline-block:行内块元素

inline:span元素默认值,*前后没有换行符*

inherit:继承父元素display

##### 盒子模型

box-sizing默认值:content-box标准模型

###### 标准模型

* 内容就是盒子的**边界**

* width=内容宽度

###### IE模型

* 边框才是盒子的边界
* width=内容宽度+padding+border

```css
/* 标准模型 */
box-sizing:content-box;
 /*IE模型*/
box-sizing:border-box;
```

##### margin折叠

即**两个和多个相邻的普通流中**的盒子,在**垂直方向上的外边距发生叠加**,这种形成的外边距称之为外边距叠加

##### rpx，px，rem单位换算规则

rpx:**不论哪个型号**的手机，屏幕宽度**都是750rpx**

px = 1rpx(750px)/设计稿宽度rpx 

假设设计稿800px,那么换算为px就是1px = 750px/800rpx

rem: 1rem = (设计稿px/20px)rpx = 37.5px

#### 网络

##### 常用http请求头

* expire
* Cache-control
* ETag
* Accept
* Authorization
* content-length
* host
* if-modifled-since
* user-agent
* cookie
* from
* range

##### get&post在跨域请求时有什么区别

get:不会触发跨域cors

post:触发跨域cors

##### HTTP 和 RTMP 区别

###### RTMP

RTMP:*实时信息传输协议*,有adobe公司提出的*应用层协议*,用来解决多*媒体数据*传输流的*多路复用和分包问题*

基于TCP来保证数据可靠性

通过握手来建立与传输层链接之上的*RTMP Connection*链接,在connection链接上会传输一些*控制信息*:setChunkSize,setACKWindowSize....

`CreateStream`命令创建一个*Stream*链接:用于*传输具有音视频的数据*

> ps:RTMP传输时会对数据做自己的*格式化*,这个格式化的消息成为*RTMP Message*
>
> *格式化的作用是为了更好的实现多路复用和分包,发送端会将Message分为带有Message ID的Chunk,客户端接收到Chunk后重组Message*

###### 区别

HTTP连接视频时通过先将FLV视频文件下载*本地缓存*,然后通过`NetConnection`的*本地连接来播放这个FLV*,所有在本地时可以找到这个FLV的痕迹的

优点:当缓存完这个FLV,就不会再连接服务器了,接收服务器资源

缺点:因为FLV没缓存到了本地,*对FLV保密性不好*

RTMP是通过NetConnection*直连*到FMS/Red5服务器,并*实时播放*服务器的FLV文件,并不用将FLV缓存到本地才可以任意播放

优点:对FLV保密性很好

缺点:消耗服务器资源,因为*连接始终是实时的*

##### HTTP是单向连接和双向认证

http是**单向的连接**

但是http双向认证指的是除了**客户端需要验证服务器**之外,**服务器也需要验证服务器**

##### HTTP请求是在单独的线程中吗

不管是浏览器中的http请求,还是程序中的http请求,都是*在单独的线程中的*

但是浏览器是对http请求进行了并发的,即浏览器多开了线程,在每个线程中都有http请求