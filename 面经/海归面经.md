#### JS

##### 修改原型上的值

```ts
__proto__
```

##### let ,const, var

仅var存在变量提升

let,const仅有暂时性死区

变量提升:
指的是在声明在使用之后,还是可以正常获取到变量

暂时性死区:

指的是let/const在声明之前使用,*因为变量还没有被当前作用域创建出来,此时还没有完成语法绑定*

而var在声明之前使用是正常的,只不过是undefined

##### 深拷贝

定义:如果仅是把当前对象赋值给另一个变量,这是赋值的引用,该变变量还是会导致原对象发生改变,深拷贝就是在当前内存中再生成一份原变量,而不是引用

内置方法

```js
JSON.stringfiy
```

手写

```ts
const deepClone = (obj) => {
  // 新建对象 | 数组
  let objClone = Array.isArray(obj) ? [] : {};
  // 判断传入的参数对象不为空
  if (obj && typeof obj === "object") {
    // 遍历所有key
    for (let key in obj) {
      // 如果对象的key也是对象
      if (obj[key] && typeof obj[key] === "object") {
        // 那么递归
        objClone[key] = deepClone(obj[key]);
      } else {
        // 反之放入新对象中
        objClone[key] = obj[key];
      }
    }
  }
  return objClone;
};
```

##### 操作dom

```js
// 获取全部div
let dom = document.querySelector("div")
// 获取id节点
let idNode = document.querySelector('#foo')
// 获取类节点
let classNode = document.querySelector(".class")
// 获取全部querySelectorAll , 内部是数组,可以使用下标进行获取单个
// let span = document.querySelector("span")
// 移除子节点
// dom.removeChild(span)
// 创建节点
// document.createElement('div', 3)
// 追加节点
// dom.appendChild(document.createElement('div', 3))
// 获取父节点
// dom.parentNode
// 获取子节点
// dom.childNodes
// 创建注释节点
// dom.appendChild(document.createComment("nihao"))
// 创建文本节点
// dom.appendChild(document.createTextNode('hello'))
```

##### 箭头函数

* 没有自己的this

* 没有arguments

* 语法简洁

* 不能用作构造函数,不能new

* 没有原型对象

  ```js
  function foo(){}
  foo.protoype // {constructor:f}
  const bar =() => {}
  bar.prototype // undefined
  ```

##### for循环的优点

程序简洁,结构清晰,循环初始化,循环变量化,循环体和循环条件位置退出

相比map,forEach**更好中途退出**

##### map,forEach区别

map 

有返回值

forEach

返回值undefined

*相同点:都接收一个执行函数,和一个this指向*

##### 如何解决精度问题

1. 使用字符串
2. 进行运算之前先将小数乘以N倍变成整数后再计算后除以之前的N倍
3. 使用第三库

##### null和undefined的区别

###### null

标识空值,即无没有东西了,不存在这个东西,GC可以删除了

###### undefined

声明后为赋值,变量提升,函数无返回都会出现undefined

##### 未声明和未定义的区别

声明:*不开辟内存*,只告诉编译器,要声明的部分存在,要*预留部分空间*

定义:要开辟内存

```js
let x //声明
let f = 1; //定义
```

#### CSS

##### position

relative:相对于其**正常位置**进行定位

Aboslute:相当于**static定位以外的第一个父元素进行定位**

fixed:相对于**浏览器窗口**进行定位

static:*元素默认值,没有定位*

inherit:继承**父元素position**

sticky:可以被认为是**相对定位和固定定位的混合**。元素在跨越特定阈值前为相对定位，之后为固定定位。设置该属性的元素并不脱离文档流，仍然保留元素原本在文档流中的位置

##### display

None:从文档流中**排除该元素**

block:块级元素,该元素*前后会有换行符*

inline-block:行内块元素

inline:span元素默认值,*前后没有换行符*

inherit:继承父元素display

##### 盒子模型

box-sizing默认值:content-box标准模型

###### 标准模型

* 内容就是盒子的**边界**

* width=内容宽度

###### IE模型

* 边框才是盒子的边界
* width=内容宽度+padding+border

```css
/* 标准模型 */
box-sizing:content-box;
 /*IE模型*/
box-sizing:border-box;
```

##### margin折叠

即**两个和多个相邻的普通流中**的盒子,在**垂直方向上的外边距发生叠加**,这种形成的外边距称之为外边距叠加

##### rpx，px，rem单位换算规则

rpx:**不论哪个型号**的手机，屏幕宽度**都是750rpx**

px = 1rpx(750px)/设计稿宽度rpx 

假设设计稿800px,那么换算为px就是1px = 750px/800rpx

rem: 1rem = (设计稿px/20px)rpx = 37.5px