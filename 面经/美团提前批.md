#### 一面

##### css实现动画，怎么让它执行完这个去执行另外一个keyFrame，你怎么知道这个动画什么时候结束

###### 方法1:

使用js设置一个与动画时间一样的定时器,等待时间到了就执行添加另外一个keyFrame

###### 方法2

`-webkit-animation`动画结束时有一个`webkitAnimationEnd`事件

不同浏览器写法

* webkitAnimationEnd 

* mozAnimationEnd 

* MSAnimationEnd 

* oanimationend 

* animationend

##### setTimeout解决爆栈

解释一下为什么会出现不同的情况

```js
//爆栈
function fo() {
  fo()
}
fo()

//不会爆栈
function fo() {
  setTimeout(() => {
    fo()
  })
}
fo()
```

>  js有*主线程,调用栈,消息队列*

示例1:

因为当前处于主线程然后执行fo(),遇到fo内部将fo()转到调用栈,然后主线程又调用了fo(),又往调用栈放入fo(),最后没有结束条件,导致调用栈爆

执行顺序:

```js
主线程调用 fo --> 压入调用栈{fo()} --> 主线程调用fo --> 压入调用栈{fo()} --> 如此循环,调用栈内的上下文一直没有得到执行,导致爆掉调用栈
```

示例2:

首先，主线程调用 foo 函数，将 foo 函数的*执行上下文压入调用栈*，之后在 foo 函数中调用*setTimeout*，主线程将 setTimeout 的*回调函数 foo 放入消息队列中*，等待执行。*外层的 foo函数执行结束*，V8 将其*执行上下文从调用栈中弹出*，此时*调用栈被清空*。接下来主线程并不会停下来，而是去消息队列中不断的取出待执行的任务并执行。等取出 setTimeout 的回调函数 foo 时，再一次开始执行 foo...

执行顺序:

```js
主线程 执行fo  --> 压入 调用栈 {setTimeout(fo())}  --> 主线程调用setTimeout   --> 主线程将setTimeout内的回调放入 消息队列  --> 外层fo执行完毕 --> 将上下文从调用栈弹出  此时调用栈清空了 --> 主线程获取消息队列任务并执行  --> 主线程执行fo  --> 一直如此循环
```

> 参考:https://zhuanlan.zhihu.com/p/162690769

##### 使用RequestAnimationFrame实现动画

```html
<body>
  <div id="div" style="font-size: 10px;">1</div>
  <script>
    let dom = document.getElementById('div');
    function anmtion() {
      if (dom.style.fontSize === '1000px') return;
      dom.style.fontSize = parseInt(dom.style.fontSize.split('px')[0]) + 1 + 'px'
      console.log(1)
      window.requestAnimationFrame(anmtion);
    }
    window.requestAnimationFrame(anmtion)
  </script>
</body>
```

##### dangerouslySetInnerHTML

>  dangerouslySetInnerHTML是*react中DOM元素下的一个属性*

dangerouslySetInnerHTML是React在浏览器中*innerHTML的替代品*

示例

```jsx
function App(){
return(
<div dangerouslySetInnerHTML={{ __html: 'This text is set using dangerouslySetInnerHTML'}}>
  
  </div>)
  }
ReactDOM.render(<App />, document.querySelector("#root"));

//效果在页面上绘制出`his text is set using dangerouslySetInnerHTML`
```

等同于

```js
document.innerHTML = `his text is set using dangerouslySetInnerHTML`
```

##### 为什么使用服务器端渲染

