#### 阿里一面

##### 用js描述一棵树

```js
class TreeNode {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
  }
}

class OperateTree {
  constructor() {
    this.root = null;
  }

  insert(val) {
    //创建TreeNode
    const newNode = new TreeNode(val);
    //插入节点
    const insertNode = (node, newNode) => {
      /**
       * 这里其实在判断left节点是否为空,
       * 假设首次 newNode.val = 1
       * 而node.val = this.root = null
       * 所以向right插入node
       *
       * 反之就向left插入
       *
       */
      if (newNode.val < node.val) {
        //如果left不存在,就插入到left
        if (node.left === null) {
          node.left = newNode;
        } else {
          //反之继续递归查找,知道查找到叶子节点
          insertNode(node.left, newNode);
        }
      } else {
        if (node.right === null) {
          node.right = newNode;
        } else {
          insertNode(node.right, newNode);
        }
      }
    };
    //如果root不存在
    if (!this.root) {
      //那么将会使用传入insert的参数创建一个TreeNode实例
      //并作为root
      this.root = newNode;
    } else {
      //反之开始递归
      insertNode(this.root, newNode);
    
  }
}

const tree = new OperateTree();
tree.insert(11);
tree.insert(12);
tree.insert(7);

console.log(tree);
```

##### new操作

```js
function _new(fn,...args){
  let obj = Object.create(fn.prototype);//创建一个新对象,并把新对象的__proto__指向fn.prototype
  let result = fn.apply(obj,fn); //改变this指向并执行构造函数保存返回结果
  return result instanceof Object ? result : obj; //如果构造函数有返回并且结果为对象,返回该对象,否则返回新对象
}
```

##### css无限循环动画

```css
body{
  background-color: aqua;
  animation: loop infinite ;
}
@keyframes loop {
  from{

  }
  to{

  }
}
```

##### 清除float

* 给浮动元素的父元素设置height
* clear:both
* 给父元素也设置float
* 给父元素设置overflow:hidden/auto
* 给父元素设置after伪元素,然后在伪元素中clear:both

##### 手写jsonp

```js
function jsonp(url, params, callback) {
  const generateUrl = () => {
    let dataSrc = "";
    for (let key in params) {
      if (params[key].hasOwnProperty) {
        dataSrc += `${key}=${params[key]}`;
      }
    }
    dataSrc += `callback=${callback}`;
    return `${url}?${dataSrc}`;
  };

  return new Promise((resolve, reject) => {
    let scriptEle = document.createElement("script");
    scriptEle.src = generateUrl();
    document.body.appendChild(scriptEle);
    //在window上创建一个函数,这里的data就是首次promise resolve后的data
    //因为最后使用jsonp是返回的promise,我们还需要then.
    /*
    这里的data就是script执行后拿到的后台返回的数据
    */
    window[callback] = (data) => {
      resolve(data);
      document.removeChild(scriptEle);
      delete window[callback];
    };
  });
}

jsonp(
  "https://www.fastmock.site/mock/8d71184b02b42959dd2d9835c1a52932/zhihu/api/follower",
  {},
  "jsoncallback"
).then((data) => {
  //打印数据
  console.log(data);
});
```

