#### 阿里一面

##### 用js描述一棵树

```js
class TreeNode {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
  }
}

class OperateTree {
  constructor() {
    this.root = null;
  }

  insert(val) {
    //创建TreeNode
    const newNode = new TreeNode(val);
    //插入节点
    const insertNode = (node, newNode) => {
      /**
       * 这里其实在判断left节点是否为空,
       * 假设首次 newNode.val = 1
       * 而node.val = this.root = null
       * 所以向right插入node
       *
       * 反之就向left插入
       *
       */
      if (newNode.val < node.val) {
        //如果left不存在,就插入到left
        if (node.left === null) {
          node.left = newNode;
        } else {
          //反之继续递归查找,知道查找到叶子节点
          insertNode(node.left, newNode);
        }
      } else {
        if (node.right === null) {
          node.right = newNode;
        } else {
          insertNode(node.right, newNode);
        }
      }
    };
    //如果root不存在
    if (!this.root) {
      //那么将会使用传入insert的参数创建一个TreeNode实例
      //并作为root
      this.root = newNode;
    } else {
      //反之开始递归
      insertNode(this.root, newNode);
    
  }
}

const tree = new OperateTree();
tree.insert(11);
tree.insert(12);
tree.insert(7);

console.log(tree);
```

##### new操作

```js
function _new(fn,...args){
  let obj = Object.create(fn.prototype);//创建一个新对象,并把新对象的__proto__指向fn.prototype
  let result = fn.apply(obj,fn); //改变this指向并执行构造函数保存返回结果
  return result instanceof Object ? result : obj; //如果构造函数有返回并且结果为对象,返回该对象,否则返回新对象
}
```

##### css无限循环动画

```css
body{
  background-color: aqua;
  animation: loop infinite ;
}
@keyframes loop {
  from{

  }
  to{

  }
}
```

##### 清除float

* 给浮动元素的父元素设置height
* clear:both
* 给父元素也设置float
* 给父元素设置overflow:hidden/auto
* 给父元素设置after伪元素,然后在伪元素中clear:both

##### 手写jsonp

```js
function jsonp(url, params, callback) {
  const generateUrl = () => {
    let dataSrc = "";
    for (let key in params) {
      if (params[key].hasOwnProperty) {
        dataSrc += `${key}=${params[key]}`;
      }
    }
    dataSrc += `callback=${callback}`;
    return `${url}?${dataSrc}`;
  };

  return new Promise((resolve, reject) => {
    let scriptEle = document.createElement("script");
    scriptEle.src = generateUrl();
    document.body.appendChild(scriptEle);
    //在window上创建一个函数,这里的data就是首次promise resolve后的data
    //因为最后使用jsonp是返回的promise,我们还需要then.
    /*
    这里的data就是script执行后拿到的后台返回的数据
    */
    window[callback] = (data) => {
      resolve(data);
      document.removeChild(scriptEle);
      delete window[callback];
    };
  });
}

jsonp(
  "https://www.fastmock.site/mock/8d71184b02b42959dd2d9835c1a52932/zhihu/api/follower",
  {},
  "jsoncallback"
).then((data) => {
  //打印数据
  console.log(data);
});
```

##### OSI七层

* 物理层

  建立,维护,断开物理层

* 数据链路层

  建立*逻辑连接*,*硬件地址*寻址

* 网络层

  *逻辑地址*寻址

  代表协议ICMP,IP,IGMP

* 传输层

  定义*传输数据的协议端口号*

  代表协议TCP,UDP

* 会话层

  建立,管理,终止*会话*

* 表示层

  数据的*表示,安全,压缩*

  JPEG,ASCLL等加密格式

* 应用层

  网络服务和最终用户的一个接口

  代表协议HTTP,FTP...

##### setTimeout为什么可以在js中异步执行

setTimout和setInterval一样的运行机制,其实是*将指定的代码移出本次执行*,等待下一次event loop,再*检测是否到指定时间*,如果到就执行,反之继续等待

> setTimeout指定的代码,即便达到了指定时间,也会*等到本次执行的所有同步代码都执行*完毕后,再执行

##### 进程和线程的区别

进程是系统进行资源分配和调度的独立单位

线程是cpu调度和分派任务的基本单位

一个进程至少拥有一个线程

线程自己不拥有系统资源*只有一点在运行中必要的资源(一组寄存器,栈等)*,

线程和**自己同属一个进程的线程共享进程所拥有的全部资源*

##### 同源的定义

```bash
protocal:host:port
```

##### cookie和session的区别

cookie:

存储在客户端

保存用户状态

由于存储在前端,需要加密

```js
加密(内容 过期时间 sign)
```

session:

保存在服务端

保存用户状态

> 一般客户端在cookie中保存该用户存储在服务端的session ID,等下一次用户需要时,前端请求携带cookie,服务器用获取到的cookie中的sessionID查找用户对应的session并返回状态

##### 死锁和四要素

> 定义:指*两个即以上的进程*在执行过程,由于*竞争资源或者由于彼此通信而造成的阻塞现象*,如果无外力作用,那么它们将*无法推进,*从而产生死锁

产生死锁的原因:

1. 系统资源不足
2. 进程运行推进的顺序不合适
3. 资源分配不当

产生死锁的必要四条件

1. 互斥条件:*一个资源*每次只能被*一个进程使用*
2. 请求和保存条件:一个进程*因请求资源阻塞时*,对*已获得的资源保存不放*
3. 不可剥夺条件:进程已获得的资源,在*未使用完之前,不能强行剥夺*
4. 循环等待条件:*如干进程*之间形成一种*头尾相接*的*循环等待资源关系*

> 只要系统发生死锁,以上条件必然成立,否则不可能发生死锁

