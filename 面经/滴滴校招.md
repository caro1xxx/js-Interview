#### 一面

##### node相关

##### 基本数据类型

* string
* number
* symbol
* bigint
* boolean
* null
* undefined

##### 引用数据类型

* map
* set
* object
* array

##### symbol和bigint

symbol

解决属性名冲突问题,,表示第一无二的值,即便同一个变量传入`symbol()`生成的值也是不同的

```js 
console.log(Symbol("hi") === Symbol("hi")); //false
```

bigint

用于当整数值*大于number数据类型支持的范围*时,就可以使用bigint,bigint能比number支持更大范围的值

##### undefined和null的区别

*都代表空*

undefined的特征是*隐藏式空值*,当在使用一个为定义的变量时就会获得,并且undefined*是全局对象的一个属性*

而null是*声明式*空值,表示这个值虽然被定义了,但*未指向任何内存*.null仅是一个*字面量,*

##### 为什么typeof(null)返回"object"

js早起实现时的错误,直到现阶段也无法修复.

原因是js初始版本中,值以`32位`存储,`前3位`表示*数据类型的标记*,其余为值

所有对象的前3位都是000作为标记,`null` 被认为是一个特殊的值，用来对应 `C` 中的 `空指针` 。但 `JavaScript` 中没有 `C` 中的指针，所以 `null` 意味着什么都没有或者 `void` 并以 `全0(32个)` 表示

##### ==和===的区别

* ==会隐式转换操作数类型
  * 会*先进行类型转换*，再确定操作数是否相等
  * 转换规则
    * 当两个操作数都为*简单类型*,字符串和布尔值都会转换成数值，再比较
    * 简单类型与引用类型比较，*对象转化成其原始类型*的值(调用valueOf())，再比较
    * 两个*都为引用类型*，则比较它们*是否指向同一个对象*
    * *null 和 undefined 相等*
    * 存在 NaN 则返回 false

* === 不会

##### 判断数据类型的方法

* typeof
* isntanceof
* constructor
* *Object.property.toString.call()*

##### instanceof原理

查找原型链

判断在其原型链中能否找到该类型的原型

*仅能判断引用类型数据*

##### 手写call()

```js
Function.prototype.fakeCall = function (context, ...args) {
  const fn = Symbol("fn");
  /**
   * context为传入的上下文,在传入的上下文中
   * 新建以fn为名称的本函数,this就代表本函数
   */
  context[fn] = this;
  //传入传入并执行,因为实在context内执行的,fn的this肯定是指向context内部的
  const res = context[fn](...args);
  //最后删除该函数
  delete context[fn];
  return res;
};
function foo() {
  console.log(this.name);
}

let obj = {
  name: "jack",
};

let res = foo.fakeCall(obj);
```

Typeof(NaN)

```js
console.log(typeof NaN); //number
```

NaN仅代表一个警告,提示不合法,但是*NaN仍是一个数字*

##### 手写new

作用:实例化对象

```js
function New(obj, ...args) {
  const newObj = Object.create(null);
  newObj.__proto__ = obj.proterty;
  let res = obj.call(obj, ...args);
  /**
   * 这里为什么判断res呢?
   * 因为如果obj.call执行完后,obj内并没有return对象,代表不能被new
   * 所以返回一个空对象即可,如果是object,那么返回这个object即可
   */
  return res instanceof Object ? res : obj;
}
```

##### Map&set

Set:

允许存储*任何类型的唯一值*,不管是原始值还是引用类型

*有序的*,顺序是插入的顺序

```js
let set = new Set([1,2,3,2,3])
set.size  // 3
set.add(4) //[1,2,3,4]
set.delete(4) // [1,2,3]
set.entries() //返回迭代器对象
set.forEach(cb,thisArg) // 与forEach 一致
set.has(3) //true
set.keys()
set.values()
set.clear() // []
```

map:

保存*键值对*,有序,任何值

一个*key*只能出现一次

```js
let map = new Map()
map.set('jack',{age:18});
map.size // 1
map.get('jack') // {age:18}
map.has('jack')
map.keys()
map.values()
map.entries()
map.forEach(cb,thisArg)
map.delete('jack') //true
map.delete('lucy') //false
map.clear()
```

##### promise的理解

是异步编程的*一种解决方案*，比传统的解决方案（回调函数）更加合理和更加强大

优点

- 链式操作减低了编码难度
- 代码可读性明显增强

promise有三种状态

Pending , fulifled,rejected

只能有pending向其他两种状态转换,无法从其他状态转换

一旦状态改变,就不会再变了

用法

```js
const p = new Promise((resolve,reject)=>{})

//参数1为fuilled状态调用,参数2为rejected状态调用
p.then((value)=>{},(rason)=>{})

//捕捉错误
p.catch(error=>{})

//当状态发生变化后都会执行,不管成功与否
p.finally()
```

##### eventloop

* 调用栈
* 微任务
* 宏任务
* 任务队列
* WEB API:代表一些异步任务,这些异步任务分为macro task和micro task

```js
function bar (){
  return Promise.resolve(1)
}

function foo(){
	return setTimeout(()=>{
    return 'hi'
  })
}
bar()
foo()

1.执行bar(),进入调用栈
2.执行return Promise.resolve(1),将它放入WEB API 微任务中
3.执行foo(),进入调用栈
4.执行setTimeout,进入WEB API 宏任务中
5.同步任务执行完毕
6.清空微任务 Promise.resolve(1)
此时setTimeout到达预定时间,return 'hi'进入任务队列
7.bar()执行完毕,弹出调用栈
8.foo()执行完毕,弹出调用栈
9.执行任务队列任务,return 'hi'
```

微任务和宏任务

```js
执行宏任务 --> 是否有微任务 ---> 执行宏任务 ...
							|
  					执行所有微任务
						微任务使用栈的结构
            先进后出
            
如果在执行过程中遇到setTimeout等会将该任务移入WEB API,等待到达指定时间后,进入任务队列(QUEUE),当调用栈被清空后,就会执行任务队列内的任务
```

