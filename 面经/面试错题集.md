* useContext

  React为函数组件编写的context,能够不要props进行深层次的数据传递

  ```js
  const context = useContext(myContext)
  ```

  context的值由上层距离当前组件最近的myContext prop决定

* useCallback && useMemo 之前面试题有写过

  * callback缓存函数
  * useMemo缓存值

  都会传入依赖,根据依赖来重新生成值或函数,避免不必要的渲染

* 自定义hook

  hook就是一个函数,只不过这个函数内可以使用hook,必须使用use开头

  ```js
  export default const useWindowSize = () => {
  	const [size,setSize] = useState(...)
  	...
  	return size
  }
  ```

* catch捕获错误之后,如果之后有then,那么还是可以执行,因为catch返回的还是promise

* 重绘或重排

  重绘和重排就发生在`布局信息计算`和`绘制`

  重排*必定*导致重绘

  获取布局信息,更改元素样式,布局结构发生变化都会导致重排或重绘

  * 避免频繁操作样式
  * 缓存布局信息,避免二次获取导致重排
  * 批量写入DOM,避免频繁写入

* 浏览器渲染过程

  1. 生成DOM
  2. 生成CSSOM
  3. 使用CSSOM和DOM构建render tree
     1. 遍历可视DOM节点
     2. 对可视节点应用CSSOM规则
     3. 生产render tree
  4. 布局信息计算
     1. 从root开始遍历渲染树
     2. 计算元素在窗口内的确切位置和大小(回流)
  5. 绘制
     1. 将render tree转化为屏幕上的像素,也就是*对应的像素绘制指令*
     2. 绘制

* component和pruecomponent的区别

  因为普通class compoent的更新是由`shouldComponentUpdate`来控制的,这个shouldComponentUpdate又是开发者自主编写逻辑

  pruecomponent自带了浅比较state和props,自行判断更新,无需`shouldComponentUpdate`,注意这里的`浅比较`,pruecomponent无法对复杂的数据结构进行深比较,会更新错误

* target和currentTarget的区别

  因为事件处理有两套机制 冒泡和捕获

  currentTarget:*绑定*事件的元素

  target:*触发*事件的元素

  在我们使用捕获的方式时,可以使用currentTarget来判断是否是指定元素触发事件

* 路由懒加载原理

  如React.lazy

  是由webpack实现的,webpack通过创建script标签,找到对应的chunk,使用script加载chunk

  chunk有对应的状态

  * 未加载
  * 加载中
  * 已加载

* 解决循环引用问题

  思路:如果当前属性在祖父级及以前出现过,说明循环引用了

  ```js
  function isReference(obj,ancestor){
  	let parents = ancestor || [obj];
    for(let key in obj){
      if(typeof obj[key] === 'object' && obj[key] !== null){
        parents.forEach((item)=>{
          if(item === obj[key]){
  					obj[key] = 'reference';
          }
        })
        obj[key] = isReference(obj[key],[...parents,obj[key]])
      }
    }
  }
  ```

* await同堵塞同步代码

  await等待的代码*会阻塞后续的同步代码*,不管是否等待的promise,当等待完毕后就会回到当前上下文继续执行

* 封装xhr

  ```js
  function generatorParmas(parmas){
    let obj = {};
    for(let key in parmas){
      if(Object.prototype.hasOwnProperty(params[key])){
  			obj[key] = params[key]
      }
    }
    return obj
  }
  function XHR(url,method,parmas){
    let xhr = new XMLHttpRequest;
    xhr.onload = function(){
      console.log(JSON.parse(xhr.response).data)
    }
    switch(method){
      case 'GET':
        xhr.open(url,method);
        xhr.send();
      	break;
      case 'POST':
        let data = generatorParmas(params)
        xhr.open(url,method);
        xhr.setRequestHeader('content-type','Application/JSON');
        xhr.send(data);
        break;
    }
  }
  ```

* Promise.all

  ```js
  function all(promiseList){
  	let res=[],count=0;
    //这个promise决定all返回的可以被then调用
  	return new Promise((resolve,reject)=>{
      promiseList.forEach(item=>{
        //将item产生结果
        item.resolve()
        .then(
          (value)=>{
            res.push(value);
            count+=1;
            if(res.length === count)return resolve(res)
        	},
          (rason)=>{
          	throw Error(rason)
        	}
        )
      })
    })
  }
  ```

* monorepo

  新的代码管理方式,非monorepo的代码仓库,一般都是一个项目一个仓库,而monorepo是将整个公司项目架构在一个仓库内,并且抽离了公用的部分,当需要修改共有依赖时,该了公用文件就可以实现修改了全部

  ```js
  //假设架构目录
  project
  	-node_module
  	-package.json
  	...
    		/project1
  				package.json
  			/project2
  				package.json
  ```

  目的就是为了复用和解耦,因为所有需要的依赖都存放在了一个共有的地方

  目前为止我是这样理解的

* useCallback useMemo使用场景

  useCallback作用是缓存函数,useMemo是缓存数值

  useCallback和useMemo的*源码实现基本一致*

  假设useCallback使用场景:

  当父组件向子组件传递一个方法,父组件因为自己的状态发生改变重新渲染,导致重新生成了这个方法,导致子组件也跟着重新渲染

  如果使用useCallback将这个方法包裹起来,就不会出现这种情况

  useMemo使用场景:

  同理当传递给子组件一个对象时,如果父组件发生重新渲染,导致这个对象重新声明,和子组件引用的这个对象内存地址不一致,导致重新渲染子组件

  使用useMemo包裹这个对象就可以解决这个问题

* diff算法过程

  diff算法仅会在同级比较

  深度优先,同级比较,从两端到中间循环

  ```js
  		startIndex                endIndex
  old:    A        B      C       D
  		startIndex                        endIndex
  new:    D        C      A       B       F
  
  //第一次循环
  发现old的endIndex和new的startIndex节点相同,复用D,new的startIndex移动到C,old的endIndex移动到C
  
  ...
  ```

  > 关键点在于一旦有*两个指针重叠,就代表循环结束*

* Vue生命周期钩子

  * beforeCreate
  * created
  * beforeMount
  * mounted
  * beforeUpdate
  * updated
  * beforeDestory
  * destoryed
  * activated
  * deactivated
  * errorCaptured

* 闭包

  函数对其*周围状态的引用捆绑在一起*时,这样的组合就叫闭包

* 变量提升

  js运行时:

  1. 创建执行上下文
     1. 创建变量对象
        1. 创建arguments,值为arguments
        2. 扫码function函数声明,创建同名属性,值为该函数的引用
        3. *扫码var变量声明,创建同名属性,值为undefined,这就是变量提升*
     2. 创建作用域链
     3. 确定this执行
  2. 将执行上下文入栈
  3. 当该执行上下文在栈顶时,运行执行上下文

* TCP三次握手

* TCP是如何实现数据可靠性的

  * 超时重传
  * 序列号
  * 确认应答
  * 校验和
  * 滑动窗口控制
  * 拥塞控制

* BFC

  BFC：block formatting context，块级格式化上下文。

  BFC是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域.

  满足下列条件之一就可触发BFC:

  - 根元素，即html
  - float的值不为none（默认）
  - overflow的值不为visible（默认）
  - display的值为table-cell, table-caption, inline-block, flex, 或者 inline-flex 中的其中一个
  - position的值为absolute或fixed

* 事件循环

* 宏任务微任务有哪些

  * 宏任务:setTimeout,setInterva,dom事件,ajax
  * 微任务:promise.then catch finally ,process.nexTick

* 对webpack的理解

  webpack是模块打包工具,可以使用webpack管理模块依赖,并编译出模块所需的静态文件

  webpack两大特色

  * 代码分割
  * loader处理各种类型的静态文件

  webpack拥有require.js和browserify的功能,已经自己的特性

  * sourceUrl和sourceMap
  * 强大的plugin
  * 代码分割,按需导入
  * 异步I/O,具有多级缓存
  * 对cjs,amd,ESM语法兼容
  * 对js,css,图片等资源支持打包
  * 串联式模块加载器和插件机制
  * 独立配置文件,webpack.config.js

* watch和computed的区别

  computed

  * 具有缓存,当依赖数据没有发生变化时,重复获取还是缓存的值
  * 仅当依赖的数据发生变化时才会重新计算
  * computed中每个属性都有一个set方法和get方法

  watch

  * 支持异步
  * 监听的数据发生变化,立马出发响应操作

* vue2无法监听数组哪些操作,以及解决方法

  * 通过下标改变数组的操作
  * 无法监听数组/对象的新增

  解决方案

  * this.$set
  * splice 数组
  * 利用临时变量
  * watch监听某个key

* vue组件通信方法

  * props
  * $emit
  * eventbus
  * provide/inject
  * $parent $root
  * ref
  * atts listeners
  * vuex

* 频繁使用eventbus造成的问题

  * 难以维护
  * 当组件销毁前需要手动清除监听事件,否则造成多次执行
  * 复用性差,多个地方重复写逻辑

* vue设置全局变量

  方法1

  ```js
  const app = createApp({})
  app.config.globalProperties.$foo
  ```

  方法2

  provide/inject

* for in和for of的区别

  For in 

  * ES3新增
  * 更适合遍历对象
  * 获取对象的键名
  * 会遍历对象的原型链
  * 对于数组,for in 能够返回数组中所有可枚举属性

  for of

  * ES6新增
  * 更适合遍历数组
  * 不会遍历原型链
  * 对于数组仅返回数组的下标对应的属性值

* 服务端渲染原理

  通过服务器完成页面的结构拼接的页面处理技术

  1. 服务器收到客户请求,得到请求url路径
  2. 根据路径,超找编写代码时的路由表对应的组件
  3. 拿到请求的数据,将数据作为props,context,store形式传入组件
  4. 返回拼接好的页面给客户端
  5. 客户端绑定事件等

* https非对称加密和对称加密

  https使用了非对称加密和对称加密

  在握手阶段使用非对称加密传输对称加密的公钥,之后开启对称加密

  *数据传输阶段使用对称加密*

  *握手阶段使用非对称加密*

* vue和react的区别

* TCP三次握手和挥手

* 同步任务和异步任务的区别

* promise.all  promise.race

* eventloop

* redux原理

* js GC

* 常见跨域方法

* TCP/IP协议分层

* 为什么挥手比握手多一次

* html,js,css放在磁盘缓存还是内存缓存

* CSSOM树和DOM树是同时解析的吗

* css权重

  * 从0开始
  * 行内样式+1000
  * id选择器+100
  * 属性选择器,class,伪类+10
  * 元素选择器,伪元素+1
  * 通配符+0


* 学习flex

  > Flex = flex-grow + flex-shrink + flex-basis
  > flex默认值 0 1 auto

  * flex-grow:代表该元素是其他flex元素的倍速
  * flex-basis:代表该元素的初始宽度

  * flex-shrink:代表该元素的宽度收缩其他flex元素的倍速*(仅在flex项目父元素设置宽度的情况下生效)*

  * flex-direction:设置flex元素的排列方向

    row:默认,row-reverse:逆序行排列,column:列排序,column-reverse:逆序列排序

  * flex-warp:在需要的时候*换行*(wrap-reverse:反方向换行,warp换行,nowarp:不换行)

  * flex-flow:flex-warp和flex-direction的简写

* 样式隔离方案

  * BEM
  * css in js
  * css mudels
  * css预处理器
  * shadow dom
  * vue scoped

* http状态码

  * 2xx成功
  * 3xx重定向
  * 4xx客户端错误
  * 5xx服务器错误

* vue组件通信方法

* 箭头函数和普通函数的区别

  * 没有自己的this
  * 不能new
  * 没有原型prototype
  * call/apply/bind无法改变this
  * 没有arguments,rest替代
  * 继承来的this永远不变
  * 不能用作generator函数
