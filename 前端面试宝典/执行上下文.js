// 执行上下文就是js代码执行环境的抽象概念
// 只要有js代码运行,那么就一定运行在执行上下文中

// 执行上下文
// 分为:
1. 全局执行上下文:仅一个,就是window对象
2. 函数执行上下文:无数个,每当有一个函数被调用就会创建一个执行上下文,
3. eval执行上下文:指运行在eval函数内的代码


// 因为全局上下文是window,也只有在全局上下文中声明的变量,能在任意位置访问
// 在函数上下文中,必须是同一个上下文中声明的变量才能被访问,如果A函数上下文想访问B函数上下文是访问不到的(除闭包)


// 生命周期
创建阶段 => 执行阶段 => 回收阶段

创建阶段
// 创建阶段即当函数被调用，但未执行任何其内部代码之前

// 创建阶段做了三件事:
1.确定this指向(the binding)
2.LexicalEnvironment(词法环境)组件被创建
3.VariableEnvironment(变量环境)组件被创建


// ExecutionContext = {  
//   ThisBinding = <this value>,     // 确定this 1️⃣
//   LexicalEnvironment = { ... },   // 词法环境 2️⃣
//   VariableEnvironment = { ... },  // 变量环境 3️⃣
// }

// 1️⃣确定this
// this不是在创建的时候确定的,而是在执行是确定的(箭头函数除外)
// 2️⃣词法环境
// 词法环境内分为两个环境:
// 1.全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null，有一个全局对象，this 的值指向这个全局对象
// 2.函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象，外部环境的引用可以是全局环境，
// 也可以是包含内部函数的外部函数环境
// 3️⃣变量环境
// 变量环境也是一个词法环境,它具有2️⃣词法环境的所有属性,3️⃣变量环境和2️⃣词法环境的区别在于:ES6中2️⃣词法环境存储函数声明和用let/const声明的变量,
// 而3️⃣变量环境仅存储用var声明的变量


执行阶段
// 在这个阶段直接变量赋值和执行操作


回收阶段
// 执行上下文出栈等待虚拟机回收执行上下文


// 执行栈
// 执行栈，也叫调用栈，具有 ***LIFO（后进先出）结构***，用于存储在代码**执行期间创建的所有执行上下文**

// 当Javascript引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中

// 每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中

