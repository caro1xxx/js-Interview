> CSSOM + DOM  = 渲染树

##### 构建渲染树

1. 从DOM树root开始,*遍历每个可见节点*
   * 一些节点是不可见的,如script标签,会被省略
   * 还有被css设置为diplay为none的
2. 对于每个可见节点,*找到对应的CSSOM规则并apply*
3. 生产出带有内容以及计算样式的可视节点

![](https://web-dev.imgix.net/image/C47gYyWYVMMhDmtYSLOWazuyePF2/b6Z2Gu6UD1x1imOu1tJV.png?auto=format&w=1428)

> visibility: hidden`不同于`display: none.
>
> hidden会被渲染为一个*空框,*而none不会出在与dom

##### 布局阶段

ok,现在我们有了渲染树,就可以进入布局阶段了

布局阶段就是*计算元素在设备视口中的确切位置和大小*,也可以成为*回流*

浏览器开始*从root遍历渲染树*

> 布局过程的输出是一个“*盒子模型*”，它精确地捕捉视口中每个元素的确切位置和大小：*所有相对测量值都转换为屏幕上的绝对像素。*

##### 绘制(绘画,光栅化)

这一阶段是比较耗时的,因为浏览器有很多工作要做

- “布局”事件捕获时间轴中的渲染树构造、位置和大小计算。
- 布局完成后，浏览器发出“Paint Setup”和“Paint”事件，将渲染树转换为屏幕上的像素。

*执行渲染树构建,布局和绘制所需的时间取决于文档的大小,应用样式和运行它的设备*

> 阴影的计算和渲染是"昂贵的"

##### TL;DR (to long,don't read 意思是如果你觉得太长,可以直接看这里的总结)

1. 处理 HTML 标记并构建 DOM 树。
2. 处理 CSS 标记并构建 CSSOM 树。
3. 将 DOM 和 CSSOM 组合成一个渲染树。
4. 在渲染树上运行布局以计算每个节点的几何形状。
5. 将各个节点绘制到屏幕上。

> *优化关键渲染路径是最小化按照上述顺序执行步骤 1 到 5 的总时间的过程*

