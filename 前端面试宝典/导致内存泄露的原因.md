> 程序中**己动态分配的堆**内存由于某种原因**未释放或无法释放**就是内存泄露

> 根据js的漏记回收机制

* 当内存中**引用的次数为0**的时候内存才会被**回收**
* 全局执行上下文中的对象**被标记为不再使用才会被释放**

#### 常见场景

> 全局变量过多

```js
// main.js
// 场景1
function a(){
    b=10;
}
a();
b++;

// 场景2
setTimeout(()=>{
    console.log(b)
},1000)
```

> 闭包,**定义了闭包就要消除闭包带来的副作用**。

```js

function closuer (){
    const b = 0;
    return (c)=> b + c
}

const render = closuer();

render();
//render执行完毕后进行清除引用即可触发GC
render = null; // 手动设置为null，GC会自己去清除
```

> 事件监听**未被移除**

> 即过多的事件监听函数,未及时清除,导致内存泄露,所以有addEventListener那么不再监听事件后就需要使用removeEventListener清除事件监听

>  缓存

```js
//解决办法,设置缓存过期时间
在进入缓存的每一个变量或者函数都附加一个时间戳,当下一个变量或函数进入缓存时,就检测当前时间和缓存内所有缓存项是否有过期缓存存在,如果有过期缓存存在,那么就清除
```

