> 在程序需要使用到内存时,可以申请使用内存,但是周而复始,一直申请内存,内存是有限的,当我们申请的某些内存不再使用时,内存并不知道释放,导致内存泄露

#### js中的垃圾回收机制(GC)

##### 标记清除

> 当变量进入执行环境是，就标记这个变量为**“进入环境“**。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为**“离开环境“**

> GC运行时会标记内存中的所有变量

> GC*运行时会标记内存中所有变量*,然后将*所有在上下文中的变量*和*被上下文中引用的变量*的*标记去掉*,剩下*没有被去掉标记*的就是*等待删除*的变量

> 随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存

##### 引用计数

> 语言引擎维护着一张**引用表**

> 保存了内存里面**所有的资源（通常是各种值）的引用次数**。如果一个值的引用次数是`0`，就表示这个值不再用到了，因此可以将这块内存释放

> 如果一个值不再需要了，引用数却不为`0`，垃圾回收机制无法释放这块内存，从而导致内存泄漏

```js
let arr = [1,2,3]
//[1,2,3]并不为被删除,因为arr一直指向着它
let arr = null
//将arr指向null,[1,2,3]也就没有变量执行它了,引用计数就为0,就会被回收
```

#### 场景内存泄露场景

```js
function foo(){
	bar = '123'
}
//此时bar将会声明到window身上,导致永远无法被删除
```

```js
function foo() {
    this.variable = "potential accidental global";
}
foo();
//和上一个例子同理
```

