> 函数式编程是一种"编程范式"（programming paradigm），一种编写程序的方法论

> 主要的编程范式有三种：**命令式编程**，**声明式编程**和**函数式编程**

> 函数式编程更**加强调程序执行的结果**而非执行的过程

> 倡导利用**若干简单的执行单元**让计算结果**不断渐进**,**逐层推导复杂**的运算，而非设计一个复杂的执行过程

```js
// 命令式编程
var array = [0, 1, 2, 3]
for(let i = 0; i < array.length; i++) {
    array[i] = Math.pow(array[i], 2)
}

// 函数式方式
[0, 1, 2, 3].map(num => Math.pow(num, 2))
```

#### 纯函数

> 函数式编程旨在尽可能的提高代码的**无状态性和不变性**
>
> 使用无副作用的函数，也就是**纯函数**
>
> 纯函数是对给定的**输入返还相同输出的函数**，并且要求你所有的数据都是不可变的，即**纯函数=无状态+数据不可变**

```js
let double = value=>value*2;
//给定相同的输入,输出永远相同
```

#### 优点

* 使用纯函数，我们可以产生可测试的代码
* 不依赖外部环境计算，不会产生副作用，提高函数的复用性
* 可读性更强 ，函数不管是否是纯函数 都会有一个语义化的名称，更便于阅读
* 可以组装成复杂任务的可能性。符合**模块化概念**及**单一职责原则**

#### 缺点

- 性能：函数式编程相对于指令式编程，**性能绝对是一个短板**，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销
- 资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对**垃圾回收所产生的压力远远超过其他编程方式**
- **递归陷阱**：在函数式编程中，为了实现迭代，通常会采用递归操作

#### 高阶函数

> 在编程中,我们操作的就是`数据`和`关系`,而这个`关系`就是函数,我们构建关系,让数据从关系中流动,使其转换为另一种属性

> 高级函数，就是**以函数作为输入或者输出的函数被称为高阶函数**

```js
let Map = (data,fn) => {
  for(let i=0; i<data.length;i++){
    fn(data[i])
  }
}

Map([1,2,3],(value)=>{console.log(value)})
```

> 高阶函数存在缓存的特性，主要是利用闭包作用

#### 柯里化

> 柯里化是把一个**多参数函数转化成一个嵌套的一元函数**的过程

```js
function curry(fn){
  return function curriedFn(..args){
    if(args.length<fn.length){
      return function(){
        return curriedFn(...args.concat([...arguments]));
      }
    }
    return fn(..args)
  }
}

const foo = (a,b,c,d) => a+b+c+d;
const myCurry = curry(foo);
myCurry(1)(2)(3)(4)
```

#### 组合与管道

> 组合函数，目的是**将多个函数组合成一个函数**

```js
function afn(a){
    return a*2;
}
function bfn(b){
    return b*3;
}
const compose = (a,b)=>c=>a(b(c));
let myfn =  compose(afn,bfn);
console.log( myfn(2));
```

