```js
https = http + ssl/tls
```

ssl是tls的前身安全套接层

tls传输层安全性协议

> SSL在*技术上位于应用层*，但从*开发者的角度*看，它是一个提供TCP服务的*运输层协议*

#### 加密原理

https由*对称加密和非对称加密组成*

##### 为什么需要加密?

因为http是明文传输,所以极有可能被人恶意劫持篡改,所以需要加密

https采用对称加密和非对称加密

##### 对称加密

对称加密就像我和你一人一把钥匙,都能打开这个宝箱,https在数据传输阶段使用的是对称加密

为什么说是数据传输阶段呢?

因为在客户端首次请求服务器时,客户端并没有这把钥匙,只有服务器有

但是如果服务器将这把钥匙发给客服端,ok,中间人来劫持了,因为这把要是也没有被加密,虽然什么人都可以看见,那把钥匙加密?,好了现在中间人不知道钥匙的内容了,但是客户端也不知道了呀!

随之而来的就是*非对称加密*

##### 非对称加密

定义:*两把钥匙一把私钥,一把公钥*,私钥加密的内容只有公钥能打开,公钥机密的内容只有私钥能打开

> 非对称加密十分耗时

看上去很安全哈

现在我们假设服务器先把公钥以明文的方式传给服务器,之后客户端向服务器传数据前先用公钥加密,这样数据就得到保证了,因为公钥加密的内容只有私钥能打开,就算这把公钥被劫持,但是公钥无法解开公钥的加密

注意,此时仅仅是客户端向服务器传输,还有服务器向客户端传输呢,这是双向的,服务器使用私钥加密向客户端传输,这可不安全

如果中间人已经劫持了公钥,服务器使用私钥加密,中间人也是可以解密的

现在需要改良非对称加密机制

##### 改良非对称加密

*两组公钥两种私钥*

服务器拥有公钥A私钥A,客户端拥有公钥B私钥B

客户端首次请求将公钥B传给服务器

服务器把公钥A传给客户端

之后客户端和服务器都使用各自收到的公钥加密内容,对方使用自己拥有的对应私钥解密

*因为发送者自身不用解密内容,所以只需要有公钥即可*

十分完美

> 但是https并没有使用这种方式,*因为仍有漏洞并且每次传输都需要非对称加密,*十分耗时

##### 非对称加密 + 对称加密

这也是https选择加密方式

1. 服务器拥有公钥A和私钥A

2. 首次请求服务器将公钥发送给客户端

3. *客户端生成一个秘钥X,并使用公钥加密这个秘钥*

   ```js
   data = publicKey(SecretX)
   ```

4. 服务器使用私钥解密SecretX,得到了对称秘钥(*这也是对称加密的起点*)

5. 后续服务器使用秘钥X加密内容,客户端使用秘钥X解密内容,(*达成对称加密*)

but,仍有漏洞

*如果中间人劫持首次服务器发送的公钥,之后伪造一个公钥发给浏览器,浏览器使用这个假公钥加密秘钥X,中间人又劫持数据,使用自己的私钥解密这个使用假公钥加密的秘钥X,从而得到了秘钥X,再使用首次劫持的真公钥A加密后发给服务器*

中间人就这样拿到了秘钥X

> 根本原因是客户端*无法确定该公钥来自指定服务器*

##### CA闪亮登场

可以理解为114电话(之前可以拨打114查询号码,现在还可以吗?)

当客户端首次服务器的公钥后,拨打114电话,查询这个公钥是否来自指定服务器,如果不是,那么就是被劫持了

*同理,服务器拨打114告知系统自己对应哪个公钥*

这个114就是*CA机构*,所有的数字证书都由CA颁发,就像是*身份证*

问题来了!

你说客户端有没有在拨打114的时候被劫持了,这个电话打到了中间人手上,然后中间人告诉你,他给的公钥是真的,滑稽🐶

实际问题就是*如何防止证书在传输的时候被篡改*

##### 防伪技术

###### 数字签名

签名过程

1. CA机构拥有非对称加密的私钥和公钥。
2. CA机构对证书明文数据T*进行hash*。
3. 对hash后的值用私钥加密，得到数字签名S。

客户端验证证书

1. 拿到证书，得到明文T，签名S。
2. 用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。
3. 用证书里指明的hash算法对明文T进行hash得到T’。
4. 显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信

##### 为什么需要hash

因为非对称加密效率低,然后证书信息一般较长,使用MD5对非对称加密后的证书进行加密生成128为的值(*所以这里不是为了安全进行hash,而是性能*,并且MD5现在也不安全了)

##### 如何证明CA机构的公钥是可信的

上面我们提到数字签名的时候客户端验证证书需要使用到公钥

那么这个公钥来自哪里?

每台电脑都自带了CA公钥

你可能又会问,世界上这么多CA结构,电脑全都有?

不是的,这个*证书之间的认证是互相联系的,A信任B,B信任C*......(*这叫信任链或者数字证书链*)

##### 终极问题:每次https请求都必须在SSL/TLS层进行握手传输秘钥(指的就是秘钥X)吗

不是!

服务器会为每个客户端维护一个session id,在TLS握手阶段传给浏览器,浏览器生成好秘钥传给服务器,服务器把该秘钥存在响应的session id下,之后浏览器每次请求都会携带sssion id,服务器自动更具session id对应的秘钥进行加解密

> 节约重新生成秘钥,传输秘钥的时间